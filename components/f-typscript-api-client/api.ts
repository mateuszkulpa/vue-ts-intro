/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Infermedica API v3
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.infermedica.com/v3".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AgeRequestModel
 */
export interface AgeRequestModel {
    /**
     * age value
     * @type {number}
     * @memberof AgeRequestModel
     */
    value: number;
    /**
     * unit in which age value was provided
     * @type {string}
     * @memberof AgeRequestModel
     */
    unit?: AgeRequestModel.UnitEnum;
}

/**
 * @export
 * @namespace AgeRequestModel
 */
export namespace AgeRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitEnum {
        Year = <any> 'year',
        Month = <any> 'month'
    }
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CategoryPublic
 */
export interface CategoryPublic {
    /**
     * 
     * @type {string}
     * @memberof CategoryPublic
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryPublic
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Choice
 */
export interface Choice {
    /**
     * 
     * @type {string}
     * @memberof Choice
     */
    id: Choice.IdEnum;
    /**
     * 
     * @type {string}
     * @memberof Choice
     */
    label: string;
}

/**
 * @export
 * @namespace Choice
 */
export namespace Choice {
    /**
     * @export
     * @enum {string}
     */
    export enum IdEnum {
        Present = <any> 'present',
        Absent = <any> 'absent',
        Unknown = <any> 'unknown'
    }
}

/**
 * 
 * @export
 * @interface ChoicePublic
 */
export interface ChoicePublic {
    /**
     * 
     * @type {string}
     * @memberof ChoicePublic
     */
    id: ChoicePublic.IdEnum;
    /**
     * 
     * @type {string}
     * @memberof ChoicePublic
     */
    label: string;
}

/**
 * @export
 * @namespace ChoicePublic
 */
export namespace ChoicePublic {
    /**
     * @export
     * @enum {string}
     */
    export enum IdEnum {
        Present = <any> 'present',
        Absent = <any> 'absent',
        Unknown = <any> 'unknown'
    }
}

/**
 * 
 * @export
 * @interface ConceptItemModel
 */
export interface ConceptItemModel {
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModel
     */
    type?: ConceptItemModel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModel
     */
    commonName?: string;
}

/**
 * @export
 * @namespace ConceptItemModel
 */
export namespace ConceptItemModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Condition = <any> 'condition',
        Symptom = <any> 'symptom',
        RiskFactor = <any> 'risk_factor',
        LabTest = <any> 'lab_test'
    }
}

/**
 * 
 * @export
 * @interface ConceptItemModelPublic
 */
export interface ConceptItemModelPublic {
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModelPublic
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModelPublic
     */
    type?: ConceptItemModelPublic.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModelPublic
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ConceptItemModelPublic
     */
    commonName?: string;
}

/**
 * @export
 * @namespace ConceptItemModelPublic
 */
export namespace ConceptItemModelPublic {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Condition = <any> 'condition',
        Symptom = <any> 'symptom',
        RiskFactor = <any> 'risk_factor',
        LabTest = <any> 'lab_test'
    }
}

/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    commonName?: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    sexFilter: Condition.SexFilterEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Condition
     */
    categories: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    prevalence?: Condition.PrevalenceEnum;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    acuteness?: Condition.AcutenessEnum;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    severity?: Condition.SeverityEnum;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof Condition
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    triageLevel?: Condition.TriageLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    recommendedChannel?: Condition.RecommendedChannelEnum;
}

/**
 * @export
 * @namespace Condition
 */
export namespace Condition {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PrevalenceEnum {
        VeryRare = <any> 'very_rare',
        Rare = <any> 'rare',
        Moderate = <any> 'moderate',
        Common = <any> 'common'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AcutenessEnum {
        Chronic = <any> 'chronic',
        ChronicWithExacerbations = <any> 'chronic_with_exacerbations',
        AcutePotentiallyChronic = <any> 'acute_potentially_chronic',
        Acute = <any> 'acute'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Mild = <any> 'mild',
        Moderate = <any> 'moderate',
        Severe = <any> 'severe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TriageLevelEnum {
        EmergencyAmbulance = <any> 'emergency_ambulance',
        Emergency = <any> 'emergency',
        Consultation24 = <any> 'consultation_24',
        Consultation = <any> 'consultation',
        SelfCare = <any> 'self_care'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RecommendedChannelEnum {
        PersonalVisit = <any> 'personal_visit',
        VideoTeleconsultation = <any> 'video_teleconsultation',
        AudioTeleconsultation = <any> 'audio_teleconsultation',
        TextTeleconsultation = <any> 'text_teleconsultation'
    }
}

/**
 * 
 * @export
 * @interface ConditionDetails
 */
export interface ConditionDetails {
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    commonName?: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    sexFilter: ConditionDetails.SexFilterEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionDetails
     */
    categories: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    prevalence?: ConditionDetails.PrevalenceEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    acuteness?: ConditionDetails.AcutenessEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    severity?: ConditionDetails.SeverityEnum;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof ConditionDetails
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    triageLevel?: ConditionDetails.TriageLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetails
     */
    recommendedChannel?: ConditionDetails.RecommendedChannelEnum;
}

/**
 * @export
 * @namespace ConditionDetails
 */
export namespace ConditionDetails {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PrevalenceEnum {
        VeryRare = <any> 'very_rare',
        Rare = <any> 'rare',
        Moderate = <any> 'moderate',
        Common = <any> 'common'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AcutenessEnum {
        Chronic = <any> 'chronic',
        ChronicWithExacerbations = <any> 'chronic_with_exacerbations',
        AcutePotentiallyChronic = <any> 'acute_potentially_chronic',
        Acute = <any> 'acute'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Mild = <any> 'mild',
        Moderate = <any> 'moderate',
        Severe = <any> 'severe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TriageLevelEnum {
        EmergencyAmbulance = <any> 'emergency_ambulance',
        Emergency = <any> 'emergency',
        Consultation24 = <any> 'consultation_24',
        Consultation = <any> 'consultation',
        SelfCare = <any> 'self_care'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RecommendedChannelEnum {
        PersonalVisit = <any> 'personal_visit',
        VideoTeleconsultation = <any> 'video_teleconsultation',
        AudioTeleconsultation = <any> 'audio_teleconsultation',
        TextTeleconsultation = <any> 'text_teleconsultation'
    }
}

/**
 * 
 * @export
 * @interface ConditionDetailsModel
 */
export interface ConditionDetailsModel {
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModel
     */
    icd10Code?: string;
    /**
     * 
     * @type {Category}
     * @memberof ConditionDetailsModel
     */
    category?: Category;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModel
     */
    prevalence?: ConditionDetailsModel.PrevalenceEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModel
     */
    severity?: ConditionDetailsModel.SeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModel
     */
    acuteness?: ConditionDetailsModel.AcutenessEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModel
     */
    triageLevel?: ConditionDetailsModel.TriageLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModel
     */
    hint?: string;
}

/**
 * @export
 * @namespace ConditionDetailsModel
 */
export namespace ConditionDetailsModel {
    /**
     * @export
     * @enum {string}
     */
    export enum PrevalenceEnum {
        VeryRare = <any> 'very_rare',
        Rare = <any> 'rare',
        Moderate = <any> 'moderate',
        Common = <any> 'common'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Mild = <any> 'mild',
        Moderate = <any> 'moderate',
        Severe = <any> 'severe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AcutenessEnum {
        Chronic = <any> 'chronic',
        ChronicWithExacerbations = <any> 'chronic_with_exacerbations',
        AcutePotentiallyChronic = <any> 'acute_potentially_chronic',
        Acute = <any> 'acute'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TriageLevelEnum {
        EmergencyAmbulance = <any> 'emergency_ambulance',
        Emergency = <any> 'emergency',
        Consultation24 = <any> 'consultation_24',
        Consultation = <any> 'consultation',
        SelfCare = <any> 'self_care'
    }
}

/**
 * 
 * @export
 * @interface ConditionDetailsModelPublic
 */
export interface ConditionDetailsModelPublic {
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModelPublic
     */
    icd10Code?: string;
    /**
     * 
     * @type {CategoryPublic}
     * @memberof ConditionDetailsModelPublic
     */
    category?: CategoryPublic;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModelPublic
     */
    prevalence?: ConditionDetailsModelPublic.PrevalenceEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModelPublic
     */
    severity?: ConditionDetailsModelPublic.SeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModelPublic
     */
    acuteness?: ConditionDetailsModelPublic.AcutenessEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModelPublic
     */
    triageLevel?: ConditionDetailsModelPublic.TriageLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionDetailsModelPublic
     */
    hint?: string;
}

/**
 * @export
 * @namespace ConditionDetailsModelPublic
 */
export namespace ConditionDetailsModelPublic {
    /**
     * @export
     * @enum {string}
     */
    export enum PrevalenceEnum {
        VeryRare = <any> 'very_rare',
        Rare = <any> 'rare',
        Moderate = <any> 'moderate',
        Common = <any> 'common'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Mild = <any> 'mild',
        Moderate = <any> 'moderate',
        Severe = <any> 'severe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AcutenessEnum {
        Chronic = <any> 'chronic',
        ChronicWithExacerbations = <any> 'chronic_with_exacerbations',
        AcutePotentiallyChronic = <any> 'acute_potentially_chronic',
        Acute = <any> 'acute'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TriageLevelEnum {
        EmergencyAmbulance = <any> 'emergency_ambulance',
        Emergency = <any> 'emergency',
        Consultation24 = <any> 'consultation_24',
        Consultation = <any> 'consultation',
        SelfCare = <any> 'self_care'
    }
}

/**
 * 
 * @export
 * @interface ConditionProbability
 */
export interface ConditionProbability {
    /**
     * condition id
     * @type {string}
     * @memberof ConditionProbability
     */
    id: string;
    /**
     * condition name
     * @type {string}
     * @memberof ConditionProbability
     */
    name: string;
    /**
     * condition common name
     * @type {string}
     * @memberof ConditionProbability
     */
    commonName?: string;
    /**
     * 
     * @type {number}
     * @memberof ConditionProbability
     */
    probability: number;
    /**
     * details of conditions, appears only if extra include_condition_details were applied
     * @type {ConditionDetailsModel}
     * @memberof ConditionProbability
     */
    conditionDetails?: ConditionDetailsModel;
}

/**
 * 
 * @export
 * @interface ConditionProbabilityPublic
 */
export interface ConditionProbabilityPublic {
    /**
     * condition id
     * @type {string}
     * @memberof ConditionProbabilityPublic
     */
    id: string;
    /**
     * condition name
     * @type {string}
     * @memberof ConditionProbabilityPublic
     */
    name: string;
    /**
     * condition common name
     * @type {string}
     * @memberof ConditionProbabilityPublic
     */
    commonName?: string;
    /**
     * 
     * @type {number}
     * @memberof ConditionProbabilityPublic
     */
    probability: number;
    /**
     * details of conditions, appears only if extra include_condition_details were applied
     * @type {ConditionDetailsModelPublic}
     * @memberof ConditionProbabilityPublic
     */
    conditionDetails?: ConditionDetailsModelPublic;
}

/**
 * 
 * @export
 * @interface ConditionPublic
 */
export interface ConditionPublic {
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    commonName?: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    sexFilter: ConditionPublic.SexFilterEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionPublic
     */
    categories: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    prevalence?: ConditionPublic.PrevalenceEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    acuteness?: ConditionPublic.AcutenessEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    severity?: ConditionPublic.SeverityEnum;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof ConditionPublic
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    triageLevel?: ConditionPublic.TriageLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionPublic
     */
    recommendedChannel?: ConditionPublic.RecommendedChannelEnum;
}

/**
 * @export
 * @namespace ConditionPublic
 */
export namespace ConditionPublic {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PrevalenceEnum {
        VeryRare = <any> 'very_rare',
        Rare = <any> 'rare',
        Moderate = <any> 'moderate',
        Common = <any> 'common'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AcutenessEnum {
        Chronic = <any> 'chronic',
        ChronicWithExacerbations = <any> 'chronic_with_exacerbations',
        AcutePotentiallyChronic = <any> 'acute_potentially_chronic',
        Acute = <any> 'acute'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Mild = <any> 'mild',
        Moderate = <any> 'moderate',
        Severe = <any> 'severe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TriageLevelEnum {
        EmergencyAmbulance = <any> 'emergency_ambulance',
        Emergency = <any> 'emergency',
        Consultation24 = <any> 'consultation_24',
        Consultation = <any> 'consultation',
        SelfCare = <any> 'self_care'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RecommendedChannelEnum {
        PersonalVisit = <any> 'personal_visit',
        VideoTeleconsultation = <any> 'video_teleconsultation',
        AudioTeleconsultation = <any> 'audio_teleconsultation',
        TextTeleconsultation = <any> 'text_teleconsultation'
    }
}

/**
 * 
 * @export
 * @interface DiagnosisRequest
 */
export interface DiagnosisRequest {
    /**
     * 
     * @type {string}
     * @memberof DiagnosisRequest
     */
    sex: DiagnosisRequest.SexEnum;
    /**
     * 
     * @type {AgeRequestModel}
     * @memberof DiagnosisRequest
     */
    age: AgeRequestModel;
    /**
     * 
     * @type {Array<Evidence>}
     * @memberof DiagnosisRequest
     */
    evidence?: Array<Evidence>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DiagnosisRequest
     */
    extras?: { [key: string]: any; };
    /**
     * time when diagnosis was evaluated in ISO 8601 format
     * @type {string}
     * @memberof DiagnosisRequest
     */
    evaluatedAt?: string;
}

/**
 * @export
 * @namespace DiagnosisRequest
 */
export namespace DiagnosisRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SexEnum {
        Male = <any> 'male',
        Female = <any> 'female'
    }
}

/**
 * 
 * @export
 * @interface DiagnosisResponse
 */
export interface DiagnosisResponse {
    /**
     * 
     * @type {Question}
     * @memberof DiagnosisResponse
     */
    question?: Question;
    /**
     * 
     * @type {Array<ConditionProbability>}
     * @memberof DiagnosisResponse
     */
    conditions?: Array<ConditionProbability>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DiagnosisResponse
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof DiagnosisResponse
     */
    hasEmergencyEvidence?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DiagnosisResponse
     */
    shouldStop?: boolean;
}

/**
 * 
 * @export
 * @interface DiagnosisResponsePublic
 */
export interface DiagnosisResponsePublic {
    /**
     * 
     * @type {QuestionPublic}
     * @memberof DiagnosisResponsePublic
     */
    question?: QuestionPublic;
    /**
     * 
     * @type {Array<ConditionProbabilityPublic>}
     * @memberof DiagnosisResponsePublic
     */
    conditions?: Array<ConditionProbabilityPublic>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DiagnosisResponsePublic
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof DiagnosisResponsePublic
     */
    hasEmergencyEvidence?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DiagnosisResponsePublic
     */
    shouldStop?: boolean;
}

/**
 * 
 * @export
 * @interface Evidence
 */
export interface Evidence {
    /**
     * id of observation or condition
     * @type {string}
     * @memberof Evidence
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    choiceId: Evidence.ChoiceIdEnum;
    /**
     * time when evidence was observed in ISO 8601 format
     * @type {string}
     * @memberof Evidence
     */
    observedAt?: string;
    /**
     * Flag describing evidence origin
     * @type {string}
     * @memberof Evidence
     */
    source?: Evidence.SourceEnum;
}

/**
 * @export
 * @namespace Evidence
 */
export namespace Evidence {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceIdEnum {
        Present = <any> 'present',
        Absent = <any> 'absent',
        Unknown = <any> 'unknown'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SourceEnum {
        Initial = <any> 'initial',
        Suggest = <any> 'suggest',
        Predefined = <any> 'predefined',
        RedFlags = <any> 'red_flags'
    }
}

/**
 * 
 * @export
 * @interface ExplanationEvidence
 */
export interface ExplanationEvidence {
    /**
     * observation id
     * @type {string}
     * @memberof ExplanationEvidence
     */
    id: string;
    /**
     * observation name
     * @type {string}
     * @memberof ExplanationEvidence
     */
    name: string;
    /**
     * observation common name
     * @type {string}
     * @memberof ExplanationEvidence
     */
    commonName?: string;
}

/**
 * 
 * @export
 * @interface ExplanationRequest
 */
export interface ExplanationRequest {
    /**
     * 
     * @type {string}
     * @memberof ExplanationRequest
     */
    sex: ExplanationRequest.SexEnum;
    /**
     * 
     * @type {AgeRequestModel}
     * @memberof ExplanationRequest
     */
    age: AgeRequestModel;
    /**
     * 
     * @type {Array<Evidence>}
     * @memberof ExplanationRequest
     */
    evidence?: Array<Evidence>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExplanationRequest
     */
    extras?: { [key: string]: any; };
    /**
     * target condition id
     * @type {string}
     * @memberof ExplanationRequest
     */
    target: string;
    /**
     * time when diagnosis was evaluated in ISO 8601 format
     * @type {string}
     * @memberof ExplanationRequest
     */
    evaluatedAt?: string;
}

/**
 * @export
 * @namespace ExplanationRequest
 */
export namespace ExplanationRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SexEnum {
        Male = <any> 'male',
        Female = <any> 'female'
    }
}

/**
 * 
 * @export
 * @interface ExplanationResponse
 */
export interface ExplanationResponse {
    /**
     * supporting evidence
     * @type {Array<ExplanationEvidence>}
     * @memberof ExplanationResponse
     */
    supportingEvidence: Array<ExplanationEvidence>;
    /**
     * conflicting evidence
     * @type {Array<ExplanationEvidence>}
     * @memberof ExplanationResponse
     */
    conflictingEvidence: Array<ExplanationEvidence>;
    /**
     * unconfirmed evidence
     * @type {Array<ExplanationEvidence>}
     * @memberof ExplanationResponse
     */
    unconfirmedEvidence: Array<ExplanationEvidence>;
}

/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * version of api release
     * @type {string}
     * @memberof Info
     */
    apiVersion?: string;
    /**
     * time of last model update in ISO 8601 format
     * @type {string}
     * @memberof Info
     */
    updatedAt: string;
    /**
     * time of last translation update in ISO 8601 format
     * @type {string}
     * @memberof Info
     */
    translationUpdatedAt: string;
    /**
     * 
     * @type {number}
     * @memberof Info
     */
    conditionsCount: number;
    /**
     * 
     * @type {number}
     * @memberof Info
     */
    symptomsCount: number;
    /**
     * 
     * @type {number}
     * @memberof Info
     */
    riskFactorsCount: number;
    /**
     * 
     * @type {number}
     * @memberof Info
     */
    labTestsCount: number;
}

/**
 * 
 * @export
 * @interface InfoPublic
 */
export interface InfoPublic {
    /**
     * version of api release
     * @type {string}
     * @memberof InfoPublic
     */
    apiVersion?: string;
    /**
     * time of last model update in ISO 8601 format
     * @type {string}
     * @memberof InfoPublic
     */
    updatedAt: string;
    /**
     * 
     * @type {number}
     * @memberof InfoPublic
     */
    conditionsCount: number;
    /**
     * 
     * @type {number}
     * @memberof InfoPublic
     */
    symptomsCount: number;
    /**
     * 
     * @type {number}
     * @memberof InfoPublic
     */
    riskFactorsCount: number;
    /**
     * 
     * @type {number}
     * @memberof InfoPublic
     */
    labTestsCount: number;
}

/**
 * 
 * @export
 * @interface ObservationMention
 */
export interface ObservationMention {
    /**
     * observation id
     * @type {string}
     * @memberof ObservationMention
     */
    id: string;
    /**
     * observation name
     * @type {string}
     * @memberof ObservationMention
     */
    name: string;
    /**
     * observation common name
     * @type {string}
     * @memberof ObservationMention
     */
    commonName?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ObservationMention
     */
    positions: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ObservationMention
     */
    orth: string;
    /**
     * 
     * @type {string}
     * @memberof ObservationMention
     */
    choiceId: ObservationMention.ChoiceIdEnum;
    /**
     * 
     * @type {number}
     * @memberof ObservationMention
     */
    headPosition: number;
}

/**
 * @export
 * @namespace ObservationMention
 */
export namespace ObservationMention {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceIdEnum {
        Present = <any> 'present',
        Absent = <any> 'absent',
        Unknown = <any> 'unknown'
    }
}

/**
 * 
 * @export
 * @interface ParseRequest
 */
export interface ParseRequest {
    /**
     * 
     * @type {AgeRequestModel}
     * @memberof ParseRequest
     */
    age: AgeRequestModel;
    /**
     * 
     * @type {string}
     * @memberof ParseRequest
     */
    sex?: ParseRequest.SexEnum;
    /**
     * user text to process
     * @type {string}
     * @memberof ParseRequest
     */
    text: string;
    /**
     * ordered list of ids of present symptoms that were already captured and can be used as context
     * @type {Array<string>}
     * @memberof ParseRequest
     */
    context?: Array<string>;
    /**
     * include tokenization details in output
     * @type {boolean}
     * @memberof ParseRequest
     */
    includeTokens?: boolean;
    /**
     * correct spelling of input text before proper analysis
     * @type {boolean}
     * @memberof ParseRequest
     */
    correctSpelling?: boolean;
    /**
     * list of concept types that should be captured
     * @type {Array<string>}
     * @memberof ParseRequest
     */
    conceptTypes?: Array<ParseRequest.ConceptTypesEnum>;
}

/**
 * @export
 * @namespace ParseRequest
 */
export namespace ParseRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SexEnum {
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConceptTypesEnum {
        Symptom = <any> 'symptom',
        RiskFactor = <any> 'risk_factor'
    }
}

/**
 * 
 * @export
 * @interface ParseResponse
 */
export interface ParseResponse {
    /**
     * list of recognized symptom or risk factor mentions
     * @type {Array<ObservationMention>}
     * @memberof ParseResponse
     */
    mentions: Array<ObservationMention>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParseResponse
     */
    tokens?: Array<string>;
    /**
     * indicates that entire input text has been parsed successfully and unambiguously
     * @type {boolean}
     * @memberof ParseResponse
     */
    obvious: boolean;
}

/**
 * 
 * @export
 * @interface Question
 */
export interface Question {
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    type?: Question.TypeEnum;
    /**
     * question text
     * @type {string}
     * @memberof Question
     */
    text: string;
    /**
     * explication of question
     * @type {string}
     * @memberof Question
     */
    explication?: string;
    /**
     * instruction to question
     * @type {Array<string>}
     * @memberof Question
     */
    instruction?: Array<string>;
    /**
     * one or more observations to evaluate
     * @type {Array<QuestionItem>}
     * @memberof Question
     */
    items: Array<QuestionItem>;
    /**
     * additional content, like images or HTML
     * @type {{ [key: string]: any; }}
     * @memberof Question
     */
    extras?: { [key: string]: any; };
}

/**
 * @export
 * @namespace Question
 */
export namespace Question {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Single = <any> 'single',
        GroupSingle = <any> 'group_single',
        GroupMultiple = <any> 'group_multiple'
    }
}

/**
 * 
 * @export
 * @interface QuestionItem
 */
export interface QuestionItem {
    /**
     * observation id
     * @type {string}
     * @memberof QuestionItem
     */
    id: string;
    /**
     * name or alias of observation
     * @type {string}
     * @memberof QuestionItem
     */
    name: string;
    /**
     * explication of question
     * @type {string}
     * @memberof QuestionItem
     */
    explication?: string;
    /**
     * instruction to question
     * @type {Array<string>}
     * @memberof QuestionItem
     */
    instruction?: Array<string>;
    /**
     * list of available answer choices
     * @type {Array<Choice>}
     * @memberof QuestionItem
     */
    choices: Array<Choice>;
}

/**
 * 
 * @export
 * @interface QuestionItemPublic
 */
export interface QuestionItemPublic {
    /**
     * observation id
     * @type {string}
     * @memberof QuestionItemPublic
     */
    id: string;
    /**
     * name or alias of observation
     * @type {string}
     * @memberof QuestionItemPublic
     */
    name: string;
    /**
     * list of available answer choices
     * @type {Array<ChoicePublic>}
     * @memberof QuestionItemPublic
     */
    choices: Array<ChoicePublic>;
}

/**
 * 
 * @export
 * @interface QuestionPublic
 */
export interface QuestionPublic {
    /**
     * 
     * @type {string}
     * @memberof QuestionPublic
     */
    type?: QuestionPublic.TypeEnum;
    /**
     * question text
     * @type {string}
     * @memberof QuestionPublic
     */
    text: string;
    /**
     * one or more observations to evaluate
     * @type {Array<QuestionItemPublic>}
     * @memberof QuestionPublic
     */
    items: Array<QuestionItemPublic>;
    /**
     * additional content, like images or HTML
     * @type {{ [key: string]: any; }}
     * @memberof QuestionPublic
     */
    extras?: { [key: string]: any; };
}

/**
 * @export
 * @namespace QuestionPublic
 */
export namespace QuestionPublic {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Single = <any> 'single',
        GroupSingle = <any> 'group_single',
        GroupMultiple = <any> 'group_multiple'
    }
}

/**
 * 
 * @export
 * @interface RationaleParam
 */
export interface RationaleParam {
    /**
     * observation or condition id
     * @type {string}
     * @memberof RationaleParam
     */
    id: string;
    /**
     * observation or condition name
     * @type {string}
     * @memberof RationaleParam
     */
    name: string;
    /**
     * observation or condition common name
     * @type {string}
     * @memberof RationaleParam
     */
    commonName?: string;
}

/**
 * 
 * @export
 * @interface RationaleRequest
 */
export interface RationaleRequest {
    /**
     * 
     * @type {string}
     * @memberof RationaleRequest
     */
    sex: RationaleRequest.SexEnum;
    /**
     * 
     * @type {AgeRequestModel}
     * @memberof RationaleRequest
     */
    age: AgeRequestModel;
    /**
     * 
     * @type {Array<Evidence>}
     * @memberof RationaleRequest
     */
    evidence?: Array<Evidence>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RationaleRequest
     */
    extras?: { [key: string]: any; };
    /**
     * time when diagnosis was evaluated in ISO 8601 format
     * @type {string}
     * @memberof RationaleRequest
     */
    evaluatedAt?: string;
}

/**
 * @export
 * @namespace RationaleRequest
 */
export namespace RationaleRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SexEnum {
        Male = <any> 'male',
        Female = <any> 'female'
    }
}

/**
 * 
 * @export
 * @interface RationaleResponse
 */
export interface RationaleResponse {
    /**
     * type
     * @type {string}
     * @memberof RationaleResponse
     */
    type: RationaleResponse.TypeEnum;
    /**
     * observation params
     * @type {Array<RationaleParam>}
     * @memberof RationaleResponse
     */
    observationParams?: Array<RationaleParam>;
    /**
     * condition params
     * @type {Array<RationaleParam>}
     * @memberof RationaleResponse
     */
    conditionParams?: Array<RationaleParam>;
}

/**
 * @export
 * @namespace RationaleResponse
 */
export namespace RationaleResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        R0 = <any> 'r0',
        R1 = <any> 'r1',
        R2 = <any> 'r2',
        R3 = <any> 'r3',
        R4 = <any> 'r4',
        R5 = <any> 'r5',
        R6 = <any> 'r6'
    }
}

/**
 * 
 * @export
 * @interface RecommendSpecialist
 */
export interface RecommendSpecialist {
    /**
     * id of specialist
     * @type {string}
     * @memberof RecommendSpecialist
     */
    id?: string;
    /**
     * name of specialist
     * @type {string}
     * @memberof RecommendSpecialist
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface RiskFactor
 */
export interface RiskFactor {
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    commonName?: string;
    /**
     * only available in object details, not in listing
     * @type {string}
     * @memberof RiskFactor
     */
    question: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    questionThirdPerson?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    sexFilter: RiskFactor.SexFilterEnum;
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    category?: string;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof RiskFactor
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactor
     */
    imageSource?: string;
}

/**
 * @export
 * @namespace RiskFactor
 */
export namespace RiskFactor {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
}

/**
 * 
 * @export
 * @interface RiskFactorDetails
 */
export interface RiskFactorDetails {
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    commonName?: string;
    /**
     * only available in object details, not in listing
     * @type {string}
     * @memberof RiskFactorDetails
     */
    question: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    questionThirdPerson?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    sexFilter: RiskFactorDetails.SexFilterEnum;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    category?: string;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof RiskFactorDetails
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorDetails
     */
    imageSource?: string;
}

/**
 * @export
 * @namespace RiskFactorDetails
 */
export namespace RiskFactorDetails {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
}

/**
 * 
 * @export
 * @interface RiskFactorPublic
 */
export interface RiskFactorPublic {
    /**
     * 
     * @type {string}
     * @memberof RiskFactorPublic
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorPublic
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorPublic
     */
    commonName?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorPublic
     */
    sexFilter: RiskFactorPublic.SexFilterEnum;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorPublic
     */
    category?: string;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof RiskFactorPublic
     */
    extras?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof RiskFactorPublic
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskFactorPublic
     */
    imageSource?: string;
}

/**
 * @export
 * @namespace RiskFactorPublic
 */
export namespace RiskFactorPublic {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
}

/**
 * 
 * @export
 * @interface SearchResult
 */
export interface SearchResult {
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    id: string;
    /**
     * matched phrase, name or its synonym
     * @type {string}
     * @memberof SearchResult
     */
    label: string;
}

/**
 * 
 * @export
 * @interface SeriousObservation
 */
export interface SeriousObservation {
    /**
     * observation id
     * @type {string}
     * @memberof SeriousObservation
     */
    id: string;
    /**
     * observation name
     * @type {string}
     * @memberof SeriousObservation
     */
    name: string;
    /**
     * observation common name
     * @type {string}
     * @memberof SeriousObservation
     */
    commonName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SeriousObservation
     */
    isEmergency?: boolean;
}

/**
 * 
 * @export
 * @interface SpecialistResponse
 */
export interface SpecialistResponse {
    /**
     * 
     * @type {RecommendSpecialist}
     * @memberof SpecialistResponse
     */
    recommendedSpecialist?: RecommendSpecialist;
    /**
     * 
     * @type {string}
     * @memberof SpecialistResponse
     */
    recommendedChannel?: SpecialistResponse.RecommendedChannelEnum;
}

/**
 * @export
 * @namespace SpecialistResponse
 */
export namespace SpecialistResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RecommendedChannelEnum {
        PersonalVisit = <any> 'personal_visit',
        VideoTeleconsultation = <any> 'video_teleconsultation',
        AudioTeleconsultation = <any> 'audio_teleconsultation',
        TextTeleconsultation = <any> 'text_teleconsultation'
    }
}

/**
 * 
 * @export
 * @interface SuggestRequest
 */
export interface SuggestRequest {
    /**
     * 
     * @type {string}
     * @memberof SuggestRequest
     */
    sex: SuggestRequest.SexEnum;
    /**
     * 
     * @type {AgeRequestModel}
     * @memberof SuggestRequest
     */
    age: AgeRequestModel;
    /**
     * 
     * @type {Array<Evidence>}
     * @memberof SuggestRequest
     */
    evidence?: Array<Evidence>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SuggestRequest
     */
    extras?: { [key: string]: any; };
    /**
     * time when diagnosis was evaluated in ISO 8601 format
     * @type {string}
     * @memberof SuggestRequest
     */
    evaluatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestRequest
     */
    suggestMethod?: SuggestRequest.SuggestMethodEnum;
}

/**
 * @export
 * @namespace SuggestRequest
 */
export namespace SuggestRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SexEnum {
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SuggestMethodEnum {
        Symptoms = <any> 'symptoms',
        DemographicRiskFactors = <any> 'demographic_risk_factors',
        EvidenceBasedRiskFactors = <any> 'evidence_based_risk_factors',
        RedFlags = <any> 'red_flags'
    }
}

/**
 * 
 * @export
 * @interface SuggestResult
 */
export interface SuggestResult {
    /**
     * 
     * @type {string}
     * @memberof SuggestResult
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestResult
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestResult
     */
    commonName?: string;
    /**
     * explication of question
     * @type {string}
     * @memberof SuggestResult
     */
    explication?: string;
    /**
     * instruction to question
     * @type {Array<string>}
     * @memberof SuggestResult
     */
    instruction?: Array<string>;
}

/**
 * 
 * @export
 * @interface SuggestResultPublic
 */
export interface SuggestResultPublic {
    /**
     * 
     * @type {string}
     * @memberof SuggestResultPublic
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestResultPublic
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestResultPublic
     */
    commonName?: string;
}

/**
 * 
 * @export
 * @interface Symptom
 */
export interface Symptom {
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    commonName?: string;
    /**
     * only available in object details, not in listing
     * @type {string}
     * @memberof Symptom
     */
    question: string;
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    questionThirdPerson?: string;
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    sexFilter: Symptom.SexFilterEnum;
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    category?: string;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof Symptom
     */
    extras?: { [key: string]: any; };
    /**
     * list of child symptoms
     * @type {any}
     * @memberof Symptom
     */
    children?: any;
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Symptom
     */
    imageSource?: string;
    /**
     * id of parent symptom
     * @type {string}
     * @memberof Symptom
     */
    parentId?: string;
    /**
     * type of relation with parent symptom
     * @type {string}
     * @memberof Symptom
     */
    parentRelation?: Symptom.ParentRelationEnum;
}

/**
 * @export
 * @namespace Symptom
 */
export namespace Symptom {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ParentRelationEnum {
        Base = <any> 'base',
        Duration = <any> 'duration',
        Severity = <any> 'severity',
        Character = <any> 'character',
        ExacerbatingFactor = <any> 'exacerbating_factor',
        DiminishingFactor = <any> 'diminishing_factor',
        Location = <any> 'location',
        Radiation = <any> 'radiation'
    }
}

/**
 * 
 * @export
 * @interface SymptomDetails
 */
export interface SymptomDetails {
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    commonName?: string;
    /**
     * only available in object details, not in listing
     * @type {string}
     * @memberof SymptomDetails
     */
    question: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    questionThirdPerson?: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    sexFilter: SymptomDetails.SexFilterEnum;
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    category?: string;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof SymptomDetails
     */
    extras?: { [key: string]: any; };
    /**
     * list of child symptoms
     * @type {any}
     * @memberof SymptomDetails
     */
    children?: any;
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomDetails
     */
    imageSource?: string;
    /**
     * id of parent symptom
     * @type {string}
     * @memberof SymptomDetails
     */
    parentId?: string;
    /**
     * type of relation with parent symptom
     * @type {string}
     * @memberof SymptomDetails
     */
    parentRelation?: SymptomDetails.ParentRelationEnum;
}

/**
 * @export
 * @namespace SymptomDetails
 */
export namespace SymptomDetails {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ParentRelationEnum {
        Base = <any> 'base',
        Duration = <any> 'duration',
        Severity = <any> 'severity',
        Character = <any> 'character',
        ExacerbatingFactor = <any> 'exacerbating_factor',
        DiminishingFactor = <any> 'diminishing_factor',
        Location = <any> 'location',
        Radiation = <any> 'radiation'
    }
}

/**
 * 
 * @export
 * @interface SymptomPublic
 */
export interface SymptomPublic {
    /**
     * 
     * @type {string}
     * @memberof SymptomPublic
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomPublic
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomPublic
     */
    commonName?: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomPublic
     */
    sexFilter: SymptomPublic.SexFilterEnum;
    /**
     * 
     * @type {string}
     * @memberof SymptomPublic
     */
    category?: string;
    /**
     * additional content, like custom properties or images
     * @type {{ [key: string]: any; }}
     * @memberof SymptomPublic
     */
    extras?: { [key: string]: any; };
    /**
     * list of child symptoms
     * @type {any}
     * @memberof SymptomPublic
     */
    children?: any;
    /**
     * 
     * @type {string}
     * @memberof SymptomPublic
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof SymptomPublic
     */
    imageSource?: string;
    /**
     * id of parent symptom
     * @type {string}
     * @memberof SymptomPublic
     */
    parentId?: string;
    /**
     * type of relation with parent symptom
     * @type {string}
     * @memberof SymptomPublic
     */
    parentRelation?: SymptomPublic.ParentRelationEnum;
}

/**
 * @export
 * @namespace SymptomPublic
 */
export namespace SymptomPublic {
    /**
     * @export
     * @enum {string}
     */
    export enum SexFilterEnum {
        Both = <any> 'both',
        Male = <any> 'male',
        Female = <any> 'female'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ParentRelationEnum {
        Base = <any> 'base',
        Duration = <any> 'duration',
        Severity = <any> 'severity',
        Character = <any> 'character',
        ExacerbatingFactor = <any> 'exacerbating_factor',
        DiminishingFactor = <any> 'diminishing_factor',
        Location = <any> 'location',
        Radiation = <any> 'radiation'
    }
}

/**
 * 
 * @export
 * @interface TriageResponse
 */
export interface TriageResponse {
    /**
     * 
     * @type {string}
     * @memberof TriageResponse
     */
    triageLevel?: TriageResponse.TriageLevelEnum;
    /**
     * 
     * @type {Array<SeriousObservation>}
     * @memberof TriageResponse
     */
    serious?: Array<SeriousObservation>;
    /**
     * 
     * @type {string}
     * @memberof TriageResponse
     */
    rootCause?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TriageResponse
     */
    teleconsultationApplicable?: boolean;
}

/**
 * @export
 * @namespace TriageResponse
 */
export namespace TriageResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TriageLevelEnum {
        EmergencyAmbulance = <any> 'emergency_ambulance',
        Emergency = <any> 'emergency',
        Consultation24 = <any> 'consultation_24',
        Consultation = <any> 'consultation',
        SelfCare = <any> 'self_care'
    }
}


/**
 * ConceptsApi - fetch parameter creator
 * @export
 */
export const ConceptsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Filter concepts by type and id.
         * @summary List filtered concepts
         * @param {string} id concept id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConcept(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getConcept.');
            }
            const localVarPath = `/concepts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all concepts.
         * @summary List all concepts
         * @param {string} [ids] ids
         * @param {string} [types] types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConcepts(ids?: string, types?: string, options: any = {}): FetchArgs {
            const localVarPath = `/concepts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConceptsApi - functional programming interface
 * @export
 */
export const ConceptsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Filter concepts by type and id.
         * @summary List filtered concepts
         * @param {string} id concept id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConcept(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConceptItemModelPublic> {
            const localVarFetchArgs = ConceptsApiFetchParamCreator(configuration).getConcept(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all concepts.
         * @summary List all concepts
         * @param {string} [ids] ids
         * @param {string} [types] types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConcepts(ids?: string, types?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConceptItemModelPublic>> {
            const localVarFetchArgs = ConceptsApiFetchParamCreator(configuration).getConcepts(ids, types, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConceptsApi - factory interface
 * @export
 */
export const ConceptsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Filter concepts by type and id.
         * @summary List filtered concepts
         * @param {string} id concept id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConcept(id: string, options?: any) {
            return ConceptsApiFp(configuration).getConcept(id, options)(fetch, basePath);
        },
        /**
         * Returns all concepts.
         * @summary List all concepts
         * @param {string} [ids] ids
         * @param {string} [types] types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConcepts(ids?: string, types?: string, options?: any) {
            return ConceptsApiFp(configuration).getConcepts(ids, types, options)(fetch, basePath);
        },
    };
};

/**
 * ConceptsApi - object-oriented interface
 * @export
 * @class ConceptsApi
 * @extends {BaseAPI}
 */
export class ConceptsApi extends BaseAPI {
    /**
     * Filter concepts by type and id.
     * @summary List filtered concepts
     * @param {string} id concept id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    public getConcept(id: string, options?: any) {
        return ConceptsApiFp(this.configuration).getConcept(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all concepts.
     * @summary List all concepts
     * @param {string} [ids] ids
     * @param {string} [types] types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    public getConcepts(ids?: string, types?: string, options?: any) {
        return ConceptsApiFp(this.configuration).getConcepts(ids, types, options)(this.fetch, this.basePath);
    }

}

/**
 * ConditionsApi - fetch parameter creator
 * @export
 */
export const ConditionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available conditions.
         * @summary List all conditions
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {boolean} [includeInternal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConditions(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'ageValue' is not null or undefined
            if (ageValue === null || ageValue === undefined) {
                throw new RequiredError('ageValue','Required parameter ageValue was null or undefined when calling getAllConditions.');
            }
            const localVarPath = `/conditions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ageValue !== undefined) {
                localVarQueryParameter['age.value'] = ageValue;
            }

            if (ageUnit !== undefined) {
                localVarQueryParameter['age.unit'] = ageUnit;
            }

            if (enableTriage3 !== undefined) {
                localVarQueryParameter['enable_triage_3'] = enableTriage3;
            }

            if (includeInternal !== undefined) {
                localVarQueryParameter['include_internal'] = includeInternal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a single condition specified by id parameter.
         * @summary Get condition by id
         * @param {string} id condition id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {boolean} [includeInternal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCondition(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCondition.');
            }
            // verify required parameter 'ageValue' is not null or undefined
            if (ageValue === null || ageValue === undefined) {
                throw new RequiredError('ageValue','Required parameter ageValue was null or undefined when calling getCondition.');
            }
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ageValue !== undefined) {
                localVarQueryParameter['age.value'] = ageValue;
            }

            if (ageUnit !== undefined) {
                localVarQueryParameter['age.unit'] = ageUnit;
            }

            if (enableTriage3 !== undefined) {
                localVarQueryParameter['enable_triage_3'] = enableTriage3;
            }

            if (includeInternal !== undefined) {
                localVarQueryParameter['include_internal'] = includeInternal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConditionsApi - functional programming interface
 * @export
 */
export const ConditionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available conditions.
         * @summary List all conditions
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {boolean} [includeInternal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConditions(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConditionPublic>> {
            const localVarFetchArgs = ConditionsApiFetchParamCreator(configuration).getAllConditions(ageValue, ageUnit, enableTriage3, includeInternal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a single condition specified by id parameter.
         * @summary Get condition by id
         * @param {string} id condition id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {boolean} [includeInternal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCondition(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConditionDetails> {
            const localVarFetchArgs = ConditionsApiFetchParamCreator(configuration).getCondition(id, ageValue, ageUnit, enableTriage3, includeInternal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConditionsApi - factory interface
 * @export
 */
export const ConditionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of all available conditions.
         * @summary List all conditions
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {boolean} [includeInternal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConditions(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options?: any) {
            return ConditionsApiFp(configuration).getAllConditions(ageValue, ageUnit, enableTriage3, includeInternal, options)(fetch, basePath);
        },
        /**
         * Returns details of a single condition specified by id parameter.
         * @summary Get condition by id
         * @param {string} id condition id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {boolean} [includeInternal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCondition(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options?: any) {
            return ConditionsApiFp(configuration).getCondition(id, ageValue, ageUnit, enableTriage3, includeInternal, options)(fetch, basePath);
        },
    };
};

/**
 * ConditionsApi - object-oriented interface
 * @export
 * @class ConditionsApi
 * @extends {BaseAPI}
 */
export class ConditionsApi extends BaseAPI {
    /**
     * Returns a list of all available conditions.
     * @summary List all conditions
     * @param {number} ageValue age value
     * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
     * @param {boolean} [enableTriage3] enable 3-level triage values
     * @param {boolean} [includeInternal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public getAllConditions(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options?: any) {
        return ConditionsApiFp(this.configuration).getAllConditions(ageValue, ageUnit, enableTriage3, includeInternal, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a single condition specified by id parameter.
     * @summary Get condition by id
     * @param {string} id condition id
     * @param {number} ageValue age value
     * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
     * @param {boolean} [enableTriage3] enable 3-level triage values
     * @param {boolean} [includeInternal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public getCondition(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, includeInternal?: boolean, options?: any) {
        return ConditionsApiFp(this.configuration).getCondition(id, ageValue, ageUnit, enableTriage3, includeInternal, options)(this.fetch, this.basePath);
    }

}

/**
 * DiagnosisApi - fetch parameter creator
 * @export
 */
export const DiagnosisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Suggests possible diagnoses and relevant observations based on provided patient information.
         * @summary Query diagnostic engine
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeDiagnosis(body: DiagnosisRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling computeDiagnosis.');
            }
            const localVarPath = `/diagnosis`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DiagnosisRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosisApi - functional programming interface
 * @export
 */
export const DiagnosisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Suggests possible diagnoses and relevant observations based on provided patient information.
         * @summary Query diagnostic engine
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeDiagnosis(body: DiagnosisRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DiagnosisResponsePublic> {
            const localVarFetchArgs = DiagnosisApiFetchParamCreator(configuration).computeDiagnosis(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DiagnosisApi - factory interface
 * @export
 */
export const DiagnosisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Suggests possible diagnoses and relevant observations based on provided patient information.
         * @summary Query diagnostic engine
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeDiagnosis(body: DiagnosisRequest, options?: any) {
            return DiagnosisApiFp(configuration).computeDiagnosis(body, options)(fetch, basePath);
        },
    };
};

/**
 * DiagnosisApi - object-oriented interface
 * @export
 * @class DiagnosisApi
 * @extends {BaseAPI}
 */
export class DiagnosisApi extends BaseAPI {
    /**
     * Suggests possible diagnoses and relevant observations based on provided patient information.
     * @summary Query diagnostic engine
     * @param {DiagnosisRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosisApi
     */
    public computeDiagnosis(body: DiagnosisRequest, options?: any) {
        return DiagnosisApiFp(this.configuration).computeDiagnosis(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ExplainApi - fetch parameter creator
 * @export
 */
export const ExplainApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Explains which evidence impact probability of selected condition.
         * @summary Query diagnostic engine for explanation
         * @param {ExplanationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeExplanation(body: ExplanationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling computeExplanation.');
            }
            const localVarPath = `/explain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExplanationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExplainApi - functional programming interface
 * @export
 */
export const ExplainApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Explains which evidence impact probability of selected condition.
         * @summary Query diagnostic engine for explanation
         * @param {ExplanationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeExplanation(body: ExplanationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExplanationResponse> {
            const localVarFetchArgs = ExplainApiFetchParamCreator(configuration).computeExplanation(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExplainApi - factory interface
 * @export
 */
export const ExplainApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Explains which evidence impact probability of selected condition.
         * @summary Query diagnostic engine for explanation
         * @param {ExplanationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeExplanation(body: ExplanationRequest, options?: any) {
            return ExplainApiFp(configuration).computeExplanation(body, options)(fetch, basePath);
        },
    };
};

/**
 * ExplainApi - object-oriented interface
 * @export
 * @class ExplainApi
 * @extends {BaseAPI}
 */
export class ExplainApi extends BaseAPI {
    /**
     * Explains which evidence impact probability of selected condition.
     * @summary Query diagnostic engine for explanation
     * @param {ExplanationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExplainApi
     */
    public computeExplanation(body: ExplanationRequest, options?: any) {
        return ExplainApiFp(this.configuration).computeExplanation(body, options)(this.fetch, this.basePath);
    }

}

/**
 * InfoApi - fetch parameter creator
 * @export
 */
export const InfoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information about data used by diagnostic engine.
         * @summary Get information about API version and model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseInfo(options: any = {}): FetchArgs {
            const localVarPath = `/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns information about data used by diagnostic engine.
         * @summary Get information about API version and model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InfoPublic> {
            const localVarFetchArgs = InfoApiFetchParamCreator(configuration).getDatabaseInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns information about data used by diagnostic engine.
         * @summary Get information about API version and model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseInfo(options?: any) {
            return InfoApiFp(configuration).getDatabaseInfo(options)(fetch, basePath);
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Returns information about data used by diagnostic engine.
     * @summary Get information about API version and model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getDatabaseInfo(options?: any) {
        return InfoApiFp(this.configuration).getDatabaseInfo(options)(this.fetch, this.basePath);
    }

}

/**
 * ParseApi - fetch parameter creator
 * @export
 */
export const ParseApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns list of mentions of observation found in given text.
         * @summary Find mentions of observations in given text
         * @param {ParseRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentions(body: ParseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getMentions.');
            }
            const localVarPath = `/parse`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParseApi - functional programming interface
 * @export
 */
export const ParseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns list of mentions of observation found in given text.
         * @summary Find mentions of observations in given text
         * @param {ParseRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentions(body: ParseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ParseApiFetchParamCreator(configuration).getMentions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ParseApi - factory interface
 * @export
 */
export const ParseApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns list of mentions of observation found in given text.
         * @summary Find mentions of observations in given text
         * @param {ParseRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMentions(body: ParseRequest, options?: any) {
            return ParseApiFp(configuration).getMentions(body, options)(fetch, basePath);
        },
    };
};

/**
 * ParseApi - object-oriented interface
 * @export
 * @class ParseApi
 * @extends {BaseAPI}
 */
export class ParseApi extends BaseAPI {
    /**
     * Returns list of mentions of observation found in given text.
     * @summary Find mentions of observations in given text
     * @param {ParseRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParseApi
     */
    public getMentions(body: ParseRequest, options?: any) {
        return ParseApiFp(this.configuration).getMentions(body, options)(this.fetch, this.basePath);
    }

}

/**
 * RationaleApi - fetch parameter creator
 * @export
 */
export const RationaleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns rationale behind the question asked by the system.
         * @summary Rationale diagnosis output
         * @param {RationaleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeRationale(body: RationaleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling computeRationale.');
            }
            const localVarPath = `/rationale`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RationaleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RationaleApi - functional programming interface
 * @export
 */
export const RationaleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns rationale behind the question asked by the system.
         * @summary Rationale diagnosis output
         * @param {RationaleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeRationale(body: RationaleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RationaleResponse> {
            const localVarFetchArgs = RationaleApiFetchParamCreator(configuration).computeRationale(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RationaleApi - factory interface
 * @export
 */
export const RationaleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns rationale behind the question asked by the system.
         * @summary Rationale diagnosis output
         * @param {RationaleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeRationale(body: RationaleRequest, options?: any) {
            return RationaleApiFp(configuration).computeRationale(body, options)(fetch, basePath);
        },
    };
};

/**
 * RationaleApi - object-oriented interface
 * @export
 * @class RationaleApi
 * @extends {BaseAPI}
 */
export class RationaleApi extends BaseAPI {
    /**
     * Returns rationale behind the question asked by the system.
     * @summary Rationale diagnosis output
     * @param {RationaleRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RationaleApi
     */
    public computeRationale(body: RationaleRequest, options?: any) {
        return RationaleApiFp(this.configuration).computeRationale(body, options)(this.fetch, this.basePath);
    }

}

/**
 * RecommendSpecialistApi - fetch parameter creator
 * @export
 */
export const RecommendSpecialistApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimates recommended specialist based on provided patient information.
         * @summary Query diagnostic engine for recommended specialist and consultation type
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeRecommendedSpecialist(body: DiagnosisRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling computeRecommendedSpecialist.');
            }
            const localVarPath = `/recommend_specialist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DiagnosisRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecommendSpecialistApi - functional programming interface
 * @export
 */
export const RecommendSpecialistApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimates recommended specialist based on provided patient information.
         * @summary Query diagnostic engine for recommended specialist and consultation type
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeRecommendedSpecialist(body: DiagnosisRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecialistResponse> {
            const localVarFetchArgs = RecommendSpecialistApiFetchParamCreator(configuration).computeRecommendedSpecialist(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RecommendSpecialistApi - factory interface
 * @export
 */
export const RecommendSpecialistApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimates recommended specialist based on provided patient information.
         * @summary Query diagnostic engine for recommended specialist and consultation type
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeRecommendedSpecialist(body: DiagnosisRequest, options?: any) {
            return RecommendSpecialistApiFp(configuration).computeRecommendedSpecialist(body, options)(fetch, basePath);
        },
    };
};

/**
 * RecommendSpecialistApi - object-oriented interface
 * @export
 * @class RecommendSpecialistApi
 * @extends {BaseAPI}
 */
export class RecommendSpecialistApi extends BaseAPI {
    /**
     * Estimates recommended specialist based on provided patient information.
     * @summary Query diagnostic engine for recommended specialist and consultation type
     * @param {DiagnosisRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendSpecialistApi
     */
    public computeRecommendedSpecialist(body: DiagnosisRequest, options?: any) {
        return RecommendSpecialistApiFp(this.configuration).computeRecommendedSpecialist(body, options)(this.fetch, this.basePath);
    }

}

/**
 * RiskFactorsApi - fetch parameter creator
 * @export
 */
export const RiskFactorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available risk factors.
         * @summary List all risk factors
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRiskFactors(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'ageValue' is not null or undefined
            if (ageValue === null || ageValue === undefined) {
                throw new RequiredError('ageValue','Required parameter ageValue was null or undefined when calling getAllRiskFactors.');
            }
            const localVarPath = `/risk_factors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ageValue !== undefined) {
                localVarQueryParameter['age.value'] = ageValue;
            }

            if (ageUnit !== undefined) {
                localVarQueryParameter['age.unit'] = ageUnit;
            }

            if (enableTriage3 !== undefined) {
                localVarQueryParameter['enable_triage_3'] = enableTriage3;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a single risk factor specified by id parameter.
         * @summary Get risk factor by id
         * @param {string} id risk factor id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRiskFactor(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRiskFactor.');
            }
            // verify required parameter 'ageValue' is not null or undefined
            if (ageValue === null || ageValue === undefined) {
                throw new RequiredError('ageValue','Required parameter ageValue was null or undefined when calling getRiskFactor.');
            }
            const localVarPath = `/risk_factors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ageValue !== undefined) {
                localVarQueryParameter['age.value'] = ageValue;
            }

            if (ageUnit !== undefined) {
                localVarQueryParameter['age.unit'] = ageUnit;
            }

            if (enableTriage3 !== undefined) {
                localVarQueryParameter['enable_triage_3'] = enableTriage3;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RiskFactorsApi - functional programming interface
 * @export
 */
export const RiskFactorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available risk factors.
         * @summary List all risk factors
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRiskFactors(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RiskFactorPublic>> {
            const localVarFetchArgs = RiskFactorsApiFetchParamCreator(configuration).getAllRiskFactors(ageValue, ageUnit, enableTriage3, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a single risk factor specified by id parameter.
         * @summary Get risk factor by id
         * @param {string} id risk factor id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRiskFactor(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RiskFactorDetails> {
            const localVarFetchArgs = RiskFactorsApiFetchParamCreator(configuration).getRiskFactor(id, ageValue, ageUnit, enableTriage3, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RiskFactorsApi - factory interface
 * @export
 */
export const RiskFactorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of all available risk factors.
         * @summary List all risk factors
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRiskFactors(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
            return RiskFactorsApiFp(configuration).getAllRiskFactors(ageValue, ageUnit, enableTriage3, options)(fetch, basePath);
        },
        /**
         * Returns details of a single risk factor specified by id parameter.
         * @summary Get risk factor by id
         * @param {string} id risk factor id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRiskFactor(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
            return RiskFactorsApiFp(configuration).getRiskFactor(id, ageValue, ageUnit, enableTriage3, options)(fetch, basePath);
        },
    };
};

/**
 * RiskFactorsApi - object-oriented interface
 * @export
 * @class RiskFactorsApi
 * @extends {BaseAPI}
 */
export class RiskFactorsApi extends BaseAPI {
    /**
     * Returns a list of all available risk factors.
     * @summary List all risk factors
     * @param {number} ageValue age value
     * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
     * @param {boolean} [enableTriage3] enable 3-level triage values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskFactorsApi
     */
    public getAllRiskFactors(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
        return RiskFactorsApiFp(this.configuration).getAllRiskFactors(ageValue, ageUnit, enableTriage3, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a single risk factor specified by id parameter.
     * @summary Get risk factor by id
     * @param {string} id risk factor id
     * @param {number} ageValue age value
     * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
     * @param {boolean} [enableTriage3] enable 3-level triage values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RiskFactorsApi
     */
    public getRiskFactor(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
        return RiskFactorsApiFp(this.configuration).getRiskFactor(id, ageValue, ageUnit, enableTriage3, options)(this.fetch, this.basePath);
    }

}

/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns list of observations matching the given phrase.
         * @summary Find observations matching given phrase
         * @param {string} phrase phrase to match
         * @param {number} ageValue age value
         * @param {'male' | 'female'} [sex] sex filter
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {number} [maxResults] maximum number of results
         * @param {Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>} [types] type of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchingObservations(phrase: string, ageValue: number, sex?: 'male' | 'female', ageUnit?: 'year' | 'month', maxResults?: number, types?: Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>, options: any = {}): FetchArgs {
            // verify required parameter 'phrase' is not null or undefined
            if (phrase === null || phrase === undefined) {
                throw new RequiredError('phrase','Required parameter phrase was null or undefined when calling getMatchingObservations.');
            }
            // verify required parameter 'ageValue' is not null or undefined
            if (ageValue === null || ageValue === undefined) {
                throw new RequiredError('ageValue','Required parameter ageValue was null or undefined when calling getMatchingObservations.');
            }
            const localVarPath = `/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (phrase !== undefined) {
                localVarQueryParameter['phrase'] = phrase;
            }

            if (sex !== undefined) {
                localVarQueryParameter['sex'] = sex;
            }

            if (ageValue !== undefined) {
                localVarQueryParameter['age.value'] = ageValue;
            }

            if (ageUnit !== undefined) {
                localVarQueryParameter['age.unit'] = ageUnit;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns list of observations matching the given phrase.
         * @summary Find observations matching given phrase
         * @param {string} phrase phrase to match
         * @param {number} ageValue age value
         * @param {'male' | 'female'} [sex] sex filter
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {number} [maxResults] maximum number of results
         * @param {Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>} [types] type of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchingObservations(phrase: string, ageValue: number, sex?: 'male' | 'female', ageUnit?: 'year' | 'month', maxResults?: number, types?: Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SearchResult>> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).getMatchingObservations(phrase, ageValue, sex, ageUnit, maxResults, types, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns list of observations matching the given phrase.
         * @summary Find observations matching given phrase
         * @param {string} phrase phrase to match
         * @param {number} ageValue age value
         * @param {'male' | 'female'} [sex] sex filter
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {number} [maxResults] maximum number of results
         * @param {Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>} [types] type of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchingObservations(phrase: string, ageValue: number, sex?: 'male' | 'female', ageUnit?: 'year' | 'month', maxResults?: number, types?: Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>, options?: any) {
            return SearchApiFp(configuration).getMatchingObservations(phrase, ageValue, sex, ageUnit, maxResults, types, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Returns list of observations matching the given phrase.
     * @summary Find observations matching given phrase
     * @param {string} phrase phrase to match
     * @param {number} ageValue age value
     * @param {'male' | 'female'} [sex] sex filter
     * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
     * @param {number} [maxResults] maximum number of results
     * @param {Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>} [types] type of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getMatchingObservations(phrase: string, ageValue: number, sex?: 'male' | 'female', ageUnit?: 'year' | 'month', maxResults?: number, types?: Array<'symptom' | 'risk_factor' | 'lab_test' | 'condition'>, options?: any) {
        return SearchApiFp(this.configuration).getMatchingObservations(phrase, ageValue, sex, ageUnit, maxResults, types, options)(this.fetch, this.basePath);
    }

}

/**
 * SuggestApi - fetch parameter creator
 * @export
 */
export const SuggestApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Suggests possible symptoms based on provided patient information.
         * @summary Suggests possible symptoms based on provided request
         * @param {SuggestRequest} body 
         * @param {number} [maxResults] maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(body: SuggestRequest, maxResults?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getSuggestions.');
            }
            const localVarPath = `/suggest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SuggestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestApi - functional programming interface
 * @export
 */
export const SuggestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Suggests possible symptoms based on provided patient information.
         * @summary Suggests possible symptoms based on provided request
         * @param {SuggestRequest} body 
         * @param {number} [maxResults] maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(body: SuggestRequest, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SuggestResultPublic>> {
            const localVarFetchArgs = SuggestApiFetchParamCreator(configuration).getSuggestions(body, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SuggestApi - factory interface
 * @export
 */
export const SuggestApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Suggests possible symptoms based on provided patient information.
         * @summary Suggests possible symptoms based on provided request
         * @param {SuggestRequest} body 
         * @param {number} [maxResults] maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(body: SuggestRequest, maxResults?: number, options?: any) {
            return SuggestApiFp(configuration).getSuggestions(body, maxResults, options)(fetch, basePath);
        },
    };
};

/**
 * SuggestApi - object-oriented interface
 * @export
 * @class SuggestApi
 * @extends {BaseAPI}
 */
export class SuggestApi extends BaseAPI {
    /**
     * Suggests possible symptoms based on provided patient information.
     * @summary Suggests possible symptoms based on provided request
     * @param {SuggestRequest} body 
     * @param {number} [maxResults] maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestApi
     */
    public getSuggestions(body: SuggestRequest, maxResults?: number, options?: any) {
        return SuggestApiFp(this.configuration).getSuggestions(body, maxResults, options)(this.fetch, this.basePath);
    }

}

/**
 * SymptomsApi - fetch parameter creator
 * @export
 */
export const SymptomsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available symptoms.
         * @summary List all symptoms
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSymptoms(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'ageValue' is not null or undefined
            if (ageValue === null || ageValue === undefined) {
                throw new RequiredError('ageValue','Required parameter ageValue was null or undefined when calling getAllSymptoms.');
            }
            const localVarPath = `/symptoms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ageValue !== undefined) {
                localVarQueryParameter['age.value'] = ageValue;
            }

            if (ageUnit !== undefined) {
                localVarQueryParameter['age.unit'] = ageUnit;
            }

            if (enableTriage3 !== undefined) {
                localVarQueryParameter['enable_triage_3'] = enableTriage3;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a single symptom specified by id parameter.
         * @summary Get symptoms by id
         * @param {string} id symptoms id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymptom(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSymptom.');
            }
            // verify required parameter 'ageValue' is not null or undefined
            if (ageValue === null || ageValue === undefined) {
                throw new RequiredError('ageValue','Required parameter ageValue was null or undefined when calling getSymptom.');
            }
            const localVarPath = `/symptoms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ageValue !== undefined) {
                localVarQueryParameter['age.value'] = ageValue;
            }

            if (ageUnit !== undefined) {
                localVarQueryParameter['age.unit'] = ageUnit;
            }

            if (enableTriage3 !== undefined) {
                localVarQueryParameter['enable_triage_3'] = enableTriage3;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SymptomsApi - functional programming interface
 * @export
 */
export const SymptomsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available symptoms.
         * @summary List all symptoms
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSymptoms(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SymptomPublic>> {
            const localVarFetchArgs = SymptomsApiFetchParamCreator(configuration).getAllSymptoms(ageValue, ageUnit, enableTriage3, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a single symptom specified by id parameter.
         * @summary Get symptoms by id
         * @param {string} id symptoms id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymptom(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SymptomDetails> {
            const localVarFetchArgs = SymptomsApiFetchParamCreator(configuration).getSymptom(id, ageValue, ageUnit, enableTriage3, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SymptomsApi - factory interface
 * @export
 */
export const SymptomsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of all available symptoms.
         * @summary List all symptoms
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSymptoms(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
            return SymptomsApiFp(configuration).getAllSymptoms(ageValue, ageUnit, enableTriage3, options)(fetch, basePath);
        },
        /**
         * Returns details of a single symptom specified by id parameter.
         * @summary Get symptoms by id
         * @param {string} id symptoms id
         * @param {number} ageValue age value
         * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
         * @param {boolean} [enableTriage3] enable 3-level triage values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymptom(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
            return SymptomsApiFp(configuration).getSymptom(id, ageValue, ageUnit, enableTriage3, options)(fetch, basePath);
        },
    };
};

/**
 * SymptomsApi - object-oriented interface
 * @export
 * @class SymptomsApi
 * @extends {BaseAPI}
 */
export class SymptomsApi extends BaseAPI {
    /**
     * Returns a list of all available symptoms.
     * @summary List all symptoms
     * @param {number} ageValue age value
     * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
     * @param {boolean} [enableTriage3] enable 3-level triage values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SymptomsApi
     */
    public getAllSymptoms(ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
        return SymptomsApiFp(this.configuration).getAllSymptoms(ageValue, ageUnit, enableTriage3, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a single symptom specified by id parameter.
     * @summary Get symptoms by id
     * @param {string} id symptoms id
     * @param {number} ageValue age value
     * @param {'year' | 'month'} [ageUnit] unit in which age value was provided
     * @param {boolean} [enableTriage3] enable 3-level triage values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SymptomsApi
     */
    public getSymptom(id: string, ageValue: number, ageUnit?: 'year' | 'month', enableTriage3?: boolean, options?: any) {
        return SymptomsApiFp(this.configuration).getSymptom(id, ageValue, ageUnit, enableTriage3, options)(this.fetch, this.basePath);
    }

}

/**
 * TriageApi - fetch parameter creator
 * @export
 */
export const TriageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimates triage level based on provided patient information.
         * @summary Query diagnostic engine for triage level
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeTriage(body: DiagnosisRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling computeTriage.');
            }
            const localVarPath = `/triage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DiagnosisRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TriageApi - functional programming interface
 * @export
 */
export const TriageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimates triage level based on provided patient information.
         * @summary Query diagnostic engine for triage level
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeTriage(body: DiagnosisRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TriageResponse> {
            const localVarFetchArgs = TriageApiFetchParamCreator(configuration).computeTriage(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TriageApi - factory interface
 * @export
 */
export const TriageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimates triage level based on provided patient information.
         * @summary Query diagnostic engine for triage level
         * @param {DiagnosisRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeTriage(body: DiagnosisRequest, options?: any) {
            return TriageApiFp(configuration).computeTriage(body, options)(fetch, basePath);
        },
    };
};

/**
 * TriageApi - object-oriented interface
 * @export
 * @class TriageApi
 * @extends {BaseAPI}
 */
export class TriageApi extends BaseAPI {
    /**
     * Estimates triage level based on provided patient information.
     * @summary Query diagnostic engine for triage level
     * @param {DiagnosisRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TriageApi
     */
    public computeTriage(body: DiagnosisRequest, options?: any) {
        return TriageApiFp(this.configuration).computeTriage(body, options)(this.fetch, this.basePath);
    }

}

